package de.ma_vin.util.layer.generator.generator;

import de.ma_vin.util.layer.generator.config.elements.Entity;
import de.ma_vin.util.layer.generator.config.elements.Models;
import de.ma_vin.util.layer.generator.config.elements.Version;
import de.ma_vin.util.layer.generator.config.elements.fields.Field;
import de.ma_vin.util.layer.generator.config.elements.references.Reference;
import de.ma_vin.util.layer.generator.logging.Log4jLogImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;

import javax.tools.JavaFileObject;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.*;

public class TransportMapperCreatorTest extends AbstractCreatorTest {

    public static final String GROUPING_NAME = "grouping";
    public static final String MAPPER_PACKAGE_NAME = BASE_PACKAGE + ".mapper";
    public static final String DTO_PACKAGE_NAME = BASE_PACKAGE + ".dto";
    public static final String DOMAIN_PACKAGE_NAME = BASE_PACKAGE + ".domain";
    public static final String DERIVED_FROM_ENTITY_NAME = "DerivedFromDummy";
    public static final String VERSION_ID = "V1";
    public static final String VERSION_ENTITY_NAME = ENTITY_NAME + VERSION_ID;
    public static final String VERSION_TARGET_ENTITY_NAME = TARGET_ENTITY_NAME + VERSION_ID;
    private TransportMapperCreator cut;
    private final List<Entity> entities = new ArrayList<>();

    @Mock
    private Entity parentEntity;
    @Mock
    private Entity derivedFromEntity;
    @Mock
    private Reference parentReference;
    @Mock
    private Entity anotherParentEntity;
    @Mock
    private Reference anotherParentReference;

    @Mock
    private Entity subEntity;
    @Mock
    private Reference subReference;


    @Mock
    private Entity versionEntity;
    @Mock
    private Entity versionTargetEntity;
    @Mock
    private Version version;
    @Mock
    private Version targetVersion;
    @Mock
    private Field versionField;
    @Mock
    private Field sharedVersionField;
    @Mock
    private Field sharedNonVersionField;
    @Mock
    private Reference versionReference;
    @Mock
    private Reference sharedVersionReference;
    @Mock
    private Reference sharedNonVersionReference;
    @Mock
    private Reference versionParentReference;

    @Override
    @BeforeEach
    public void setUp() {
        super.setUp();
        cut = new TransportMapperCreator(config, new Log4jLogImpl()) {
            @Override
            protected BufferedWriter createBufferedWriter(File classFile) {
                return mockBufferedWriter(classFile.getName());
            }

            @Override
            protected BufferedWriter createBufferedWriter(JavaFileObject javaFileObject) {
                return mockBufferedWriter(javaFileObject.getName());
            }

            @Override
            protected File createFile(File dir, String fileName) {
                File createdFile = mock(File.class);
                when(createdFile.getName()).thenReturn(fileName);
                when(createdFile.getParentFile()).thenReturn(dir);
                return createdFile;
            }
        };

        entities.clear();
        entities.add(entity);
    }

    @Override
    protected void initDefaultMock() {
        super.initDefaultMock();

        when(parentEntity.getBaseName()).thenReturn("Owner");
        when(parentEntity.getDescription()).thenReturn("Owner description");
        when(parentEntity.getIdentificationPrefix()).thenReturn("OW");
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(parentEntity.getGrouping()).thenReturn(null);
        when(parentEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(parentEntity.hasNoParent()).thenReturn(Boolean.TRUE);

        when(parentReference.getTargetEntity()).thenReturn("Owner");
        when(parentReference.getRealTargetEntity()).thenReturn(parentEntity);
        when(parentReference.getReferenceName()).thenReturn("dummy");
        when(parentReference.isList()).thenReturn(Boolean.TRUE);
        when(parentReference.isOwner()).thenReturn(Boolean.TRUE);

        when(anotherParentEntity.getBaseName()).thenReturn("AnotherOwner");
        when(anotherParentEntity.getDescription()).thenReturn("Another owner description");
        when(anotherParentEntity.getIdentificationPrefix()).thenReturn("AOW");
        when(anotherParentEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(anotherParentEntity.getGrouping()).thenReturn(null);
        when(anotherParentEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(anotherParentEntity.hasNoParent()).thenReturn(Boolean.TRUE);

        when(anotherParentReference.getTargetEntity()).thenReturn("AnotherOwner");
        when(anotherParentReference.getRealTargetEntity()).thenReturn(anotherParentEntity);
        when(anotherParentReference.getReferenceName()).thenReturn("anotherDummy");
        when(anotherParentReference.isList()).thenReturn(Boolean.TRUE);
        when(anotherParentReference.isOwner()).thenReturn(Boolean.TRUE);

        when(subEntity.getBaseName()).thenReturn("Child");
        when(subEntity.getDescription()).thenReturn("child description");
        when(subEntity.getIdentificationPrefix()).thenReturn("CH");
        when(subEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(subEntity.getGrouping()).thenReturn(grouping);
        when(subEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(subEntity.hasNoParent()).thenReturn(Boolean.TRUE);

        when(subReference.getTargetEntity()).thenReturn("Child");
        when(subReference.getRealTargetEntity()).thenReturn(subEntity);
        when(subReference.getReferenceName()).thenReturn("child");
        when(subReference.isList()).thenReturn(Boolean.TRUE);
        when(subReference.isOwner()).thenReturn(Boolean.TRUE);

        mockVersions();
    }

    private void mockVersions() {
        mockEntityDefault(versionEntity);
        when(versionEntity.getBaseName()).thenReturn(VERSION_ENTITY_NAME);
        when(versionEntity.getTableName()).thenReturn(VERSION_ENTITY_NAME);
        when(versionEntity.getActualVersion()).thenReturn(version);

        when(version.getParentEntity()).thenReturn(entity);
        when(version.getVersionEntity()).thenReturn(versionEntity);
        when(version.getVersionId()).thenReturn(VERSION_ID);
        when(version.getVersionName()).thenReturn(VERSION_ENTITY_NAME);

        mockTargetEntityDefault(versionTargetEntity);
        when(versionTargetEntity.getBaseName()).thenReturn(VERSION_TARGET_ENTITY_NAME);
        when(versionTargetEntity.getTableName()).thenReturn(VERSION_TARGET_ENTITY_NAME);
        when(versionTargetEntity.getActualVersion()).thenReturn(targetVersion);

        when(targetVersion.getParentEntity()).thenReturn(targetEntity);
        when(targetVersion.getVersionEntity()).thenReturn(versionTargetEntity);
        when(targetVersion.getVersionId()).thenReturn(VERSION_ID);
        when(targetVersion.getVersionName()).thenReturn(VERSION_TARGET_ENTITY_NAME);

        mockVersionFields();
        mockVersionReferences();
    }

    private void mockVersionFields() {
        when(versionField.getFieldName()).thenReturn(FIELD_NAME + VERSION_ID);
        when(versionField.getType()).thenReturn(FIELD_TYPE);
        when(versionField.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(versionField.getParentEntity()).thenReturn(versionEntity);

        when(sharedVersionField.getFieldName()).thenReturn(FIELD_NAME + "Shared");
        when(sharedVersionField.getType()).thenReturn(FIELD_TYPE);
        when(sharedVersionField.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(sharedVersionField.getParentEntity()).thenReturn(versionEntity);

        when(sharedNonVersionField.getFieldName()).thenReturn(FIELD_NAME + "Shared");
        when(sharedNonVersionField.getType()).thenReturn(FIELD_TYPE);
        when(sharedNonVersionField.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(sharedNonVersionField.getParentEntity()).thenReturn(entity);
    }

    private void mockVersionReferences() {
        setMockReturnsReference(versionReference, TARGET_REFERENCE_NAME + VERSION_ID, TARGET_ENTITY_NAME, null, null, Boolean.FALSE, Boolean.TRUE);
        setMockReturnsReference(versionReference, versionEntity, targetEntity, null);

        setMockReturnsReference(sharedVersionReference, TARGET_REFERENCE_NAME + "Shared", TARGET_ENTITY_NAME, null, null, Boolean.FALSE, Boolean.TRUE);
        setMockReturnsReference(sharedVersionReference, versionEntity, targetEntity, null);

        setMockReturnsReference(sharedNonVersionReference, TARGET_REFERENCE_NAME + "Shared", TARGET_ENTITY_NAME, null, null, Boolean.FALSE, Boolean.TRUE);
        setMockReturnsReference(sharedNonVersionReference, entity, targetEntity, null);

        setMockReturnsReference(versionParentReference, TARGET_REFERENCE_NAME + "Shared", ENTITY_NAME, null, null, Boolean.FALSE, Boolean.TRUE);
        setMockReturnsReference(versionParentReference, versionTargetEntity, versionEntity, null);
        when(versionParentReference.isReverse()).thenReturn(Boolean.TRUE);
    }

    @DisplayName("create transport mapper with common file")
    @Test
    public void testCreateTransportMapperCommonFile() {
        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);

        verify(processingEnv, never()).getFiler();
    }

    @DisplayName("create transport mapper with java file object")
    @Test
    public void testCreateTransportMapperJavaFileObject() throws IOException {
        List<String> expected = getDefaultExpected();
        cut.setGenerateJavaFileObject(true);
        cut.setProcessingEnv(Optional.of(processingEnv));

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.empty()));

        checkSingleFile(String.format("%s.%sTransportMapper", MAPPER_PACKAGE_NAME, AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);

        verify(processingEnv).getFiler();
        verify(filer).createSourceFile(eq(String.format("%s.%sTransportMapper", MAPPER_PACKAGE_NAME, AbstractCreator.getUpperFirst(GROUPING_NAME))));
    }

    private List<String> getDefaultExpected() {
        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        return expected;
    }

    @Test
    public void testCreateTransportMapperField() {
        when(entity.getFields()).thenReturn(Arrays.asList(field));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("		dto.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("		domain.setAnyField(dto.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");


        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperSingleRef() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRef(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperSingleRefNotOwner() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		dto.setTargetRef(GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		domain.setTargetRef(GroupTransportMapper.convertToTarget(dto.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperMultiRef() {
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperMultiRefNotOwner() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperParentSingleRef() {
        when(entity.getParentRefs()).thenReturn(Arrays.asList(parentReference));
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(parentReference.isList()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.OwnerDto;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, OwnerDto parent) {");
        expected.add("		return convertToDummyDto(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, OwnerDto parent, Map<String, ITransportable> mappedObjects) {");
        expected.add("		DummyDto result = convertToDummyDto(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRef(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperMultiParentSingleRef() {
        when(entity.getParentRefs()).thenReturn(Arrays.asList(parentReference, anotherParentReference));
        when(parentReference.isList()).thenReturn(Boolean.FALSE);
        when(anotherParentReference.isList()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.AnotherOwner;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.AnotherOwnerDto;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.OwnerDto;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, AnotherOwner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, AnotherOwner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setAnotherDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, AnotherOwnerDto parent) {");
        expected.add("		return convertToDummyDto(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, AnotherOwnerDto parent, Map<String, ITransportable> mappedObjects) {");
        expected.add("		DummyDto result = convertToDummyDto(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setAnotherDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, OwnerDto parent) {");
        expected.add("		return convertToDummyDto(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, OwnerDto parent, Map<String, ITransportable> mappedObjects) {");
        expected.add("		DummyDto result = convertToDummyDto(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperParentMultiRef() {
        when(entity.getParentRefs()).thenReturn(Arrays.asList(parentReference));
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetReference.getParent()).thenReturn(entity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperSingleRefWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Arrays.asList(subReference));
        when(subReference.getParent()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRef(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }


    @Test
    public void testCreateTransportMapperSingleRefNotOwnerWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Arrays.asList(subReference));
        when(subReference.getParent()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		dto.setTargetRef(GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		domain.setTargetRef(GroupTransportMapper.convertToTarget(dto.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperMultiRefWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Arrays.asList(subReference));
        when(subReference.getParent()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperMultiRefNotOwnerWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Arrays.asList(subReference));
        when(subReference.getParent()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperNothingToMap() {
        when(entity.getModels()).thenReturn(Models.DTO);
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dto");

        when(entity.getModels()).thenReturn(Models.DOMAIN);
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only domain");

        when(entity.getModels()).thenReturn(Models.DAO);
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dao");
    }

    @Test
    public void testCreateTransportMapperNoAllToMap() {
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DAO);
        when(subEntity.getModels()).thenReturn(Models.DTO);
        entities.add(parentEntity);
        entities.add(subEntity);

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefParentNotRelevant() {
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DAO);
        when(entity.getParentRefs()).thenReturn(Arrays.asList(parentReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefParentNotRelevant() {
        when(entity.getParentRefs()).thenReturn(Arrays.asList(parentReference));
        when(parentReference.isList()).thenReturn(Boolean.FALSE);
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DAO);

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefChildNotRelevant() {
        when(targetEntity.getModels()).thenReturn(Models.DOMAIN_DAO);
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefChildNotRelevant() {
        when(targetEntity.getModels()).thenReturn(Models.DOMAIN_DAO);
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperAbstract() {
        when(entity.getIsAbstract()).thenReturn(Boolean.TRUE);

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dto");
    }

    @Test
    public void testCreateAccessMapperWithParent() {
        when(entity.getParent()).thenReturn("AnotherDummy");
        when(entity.getRealParent()).thenReturn(parentEntity);
        when(entity.hasParent()).thenReturn(Boolean.TRUE);
        when(entity.hasNoParent()).thenReturn(Boolean.FALSE);
        when(parentEntity.getIsAbstract()).thenReturn(Boolean.TRUE);
        when(parentEntity.getBaseName()).thenReturn("AnotherDummy");
        when(parentEntity.getReferences()).thenReturn(Arrays.asList(subReference));
        when(parentEntity.getFields()).thenReturn(Arrays.asList(field));
        when(subReference.getParent()).thenReturn(parentEntity);
        when(subReference.isList()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToChildDto(domain.getChild(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("		dto.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToChild(dto.getChild(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("		domain.setAnyField(dto.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAbstractTransportMapper() {
        File mapperPackageDir = mock(File.class);
        when(mapperPackageDir.getName()).thenReturn("mapperPackageDir");
        when(mapperPackageDir.getParentFile()).thenReturn(null);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated abstract class which provides generic methods to convert a data transport to a domain object and the other way around");
        expected.add(" */");
        expected.add("public abstract class AbstractTransportMapper extends AbstractMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link ITransportable} to an {@link IIdentifiable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends ITransportable, T extends IIdentifiable> T convertToDomain(S convertFrom, Map<String, IIdentifiable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, s -> s.getClass().getSimpleName() + s.getId().longValue(), (s, t) -> t.setId(s.getId()));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiable} to an {@link ITransportable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link ITransportable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link ITransportable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiable, T extends ITransportable> T convertToDto(S convertFrom, Map<String, ITransportable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, s -> s.getClass().getSimpleName() + s.getId().longValue(), (s, t) -> t.setId(s.getId()));");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAbstractTransportMapper(MAPPER_PACKAGE_NAME, Optional.of(mapperPackageDir), DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME));
        checkSingleFile(String.format("%s.java", TransportMapperCreator.ABSTRACT_TRANSPORT_MAPPER_CLASS_NAME), expected);
    }

    @Test
    public void testCreateAbstractTransportMapperUseIdGenerator() {
        File mapperPackageDir = mock(File.class);
        when(mapperPackageDir.getName()).thenReturn("mapperPackageDir");
        when(mapperPackageDir.getParentFile()).thenReturn(null);

        when(config.isUseIdGenerator()).thenReturn(Boolean.TRUE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated abstract class which provides generic methods to convert a data transport to a domain object and the other way around");
        expected.add(" */");
        expected.add("public abstract class AbstractTransportMapper extends AbstractMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link ITransportable} to an {@link IIdentifiable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends ITransportable, T extends IIdentifiable> T convertToDomain(S convertFrom, Map<String, IIdentifiable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, S::getIdentification, (s, t) -> t.setIdentification(s.getIdentification()));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiable} to an {@link ITransportable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link ITransportable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link ITransportable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiable, T extends ITransportable> T convertToDto(S convertFrom, Map<String, ITransportable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, S::getIdentification, (s, t) -> t.setIdentification(s.getIdentification()));");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAbstractTransportMapper(MAPPER_PACKAGE_NAME, Optional.of(mapperPackageDir), DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME));
        checkSingleFile(String.format("%s.java", TransportMapperCreator.ABSTRACT_TRANSPORT_MAPPER_CLASS_NAME), expected);
    }


    @Test
    public void testCreateTransportMapperFieldDerivedFrom() {
        when(entity.getFields()).thenReturn(Arrays.asList(field));
        when(entity.getModels()).thenReturn(Models.DTO);
        when(entity.getRealDerivedFrom()).thenReturn(derivedFromEntity);
        when(derivedFromEntity.getBaseName()).thenReturn(DERIVED_FROM_ENTITY_NAME);
        when(derivedFromEntity.getTableName()).thenReturn(DERIVED_FROM_ENTITY_NAME);
        when(derivedFromEntity.getDescription()).thenReturn("Dummy description");
        when(derivedFromEntity.getIdentificationPrefix()).thenReturn("DU");
        when(derivedFromEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(derivedFromEntity.getGrouping()).thenReturn(grouping);
        when(derivedFromEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(derivedFromEntity.hasNoParent()).thenReturn(Boolean.TRUE);
        when(derivedFromEntity.getGenIdIfDto()).thenReturn(Boolean.TRUE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.group.DerivedFromDummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DerivedFromDummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param derivedFromDummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(DerivedFromDummy derivedFromDummy) {");
        expected.add("		return convertToDummyDto(derivedFromDummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DerivedFromDummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param derivedFromDummy the source object which should be converted");
        expected.add("	 * @param mappedObjects    map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto}");
        expected.add("	 *                         will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(DerivedFromDummy derivedFromDummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(derivedFromDummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(DerivedFromDummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoValues(DerivedFromDummy domain, DummyDto dto) {");
        expected.add("		dto.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");


        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateTransportMapperSingleRefDerivedFrom() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference));
        when(entity.getRealDerivedFrom()).thenReturn(derivedFromEntity);
        when(derivedFromEntity.getBaseName()).thenReturn(DERIVED_FROM_ENTITY_NAME);
        when(derivedFromEntity.getTableName()).thenReturn(DERIVED_FROM_ENTITY_NAME);
        when(derivedFromEntity.getDescription()).thenReturn("Dummy description");
        when(derivedFromEntity.getIdentificationPrefix()).thenReturn("DU");
        when(derivedFromEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(derivedFromEntity.getGrouping()).thenReturn(grouping);
        when(derivedFromEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(derivedFromEntity.hasNoParent()).thenReturn(Boolean.TRUE);
        when(derivedFromEntity.getGenIdIfDto()).thenReturn(Boolean.TRUE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.group.DerivedFromDummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DerivedFromDummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param derivedFromDummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(DerivedFromDummy derivedFromDummy) {");
        expected.add("		return convertToDummyDto(derivedFromDummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DerivedFromDummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param derivedFromDummy the source object which should be converted");
        expected.add("	 * @param mappedObjects    map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto}");
        expected.add("	 *                         will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(DerivedFromDummy derivedFromDummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(derivedFromDummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(DerivedFromDummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(DerivedFromDummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @DisplayName("Create transport mapper with a versioned entity")
    @Test
    public void testCreateTransportMapperVersion() {
        when(entity.getVersions()).thenReturn(Collections.singletonList(version));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import de.test.package.dto.group.DummyV1Dto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1 the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1) {");
        expected.add("		return convertToDummy(dummyV1, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1       the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummyV1} is contained, the found {@link Dummy} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummyV1, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto}");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy) {");
        expected.add("		return convertToDummyV1Dto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyV1Dto, (domain, dto) -> getInstance().setDummyV1DtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyV1DtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyV1Dto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyV1DtoSingleReferences(Dummy domain, DummyV1Dto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyV1DtoValues(Dummy domain, DummyV1Dto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyV1Dto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");


        getDefaultExpected().forEach(l -> assertTrue(expected.contains(l), "The actual expected has to be an extension of the default one"));
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }


    @DisplayName("Create transport mapper with a versioned entity but different fields")
    @Test
    public void testCreateTransportMapperVersionDifferentFields() {
        when(entity.getVersions()).thenReturn(Collections.singletonList(version));
        when(entity.getFields()).thenReturn(Arrays.asList(field, sharedNonVersionField));
        when(versionEntity.getFields()).thenReturn(Arrays.asList(versionField, sharedVersionField));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import de.test.package.dto.group.DummyV1Dto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1 the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1) {");
        expected.add("		return convertToDummy(dummyV1, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1       the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummyV1} is contained, the found {@link Dummy} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummyV1, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto}");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy) {");
        expected.add("		return convertToDummyV1Dto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyV1Dto, (domain, dto) -> getInstance().setDummyV1DtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyV1DtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("		dto.setAnyField(domain.getAnyField());");
        expected.add("		dto.setAnyFieldShared(domain.getAnyFieldShared());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyV1Dto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyV1DtoSingleReferences(Dummy domain, DummyV1Dto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyV1DtoValues(Dummy domain, DummyV1Dto dto) {");
        expected.add("		dto.setAnyFieldShared(domain.getAnyFieldShared());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("		domain.setAnyField(dto.getAnyField());");
        expected.add("		domain.setAnyFieldShared(dto.getAnyFieldShared());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyV1Dto dto, Dummy domain) {");
        expected.add("		domain.setAnyFieldShared(dto.getAnyFieldShared());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @DisplayName("Create transport mapper with a versioned entity but different references")
    @Test
    public void testCreateTransportMapperVersionDifferentReferences() {
        when(entity.getVersions()).thenReturn(Collections.singletonList(version));
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference, sharedNonVersionReference));
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);

        when(versionEntity.getReferences()).thenReturn(Arrays.asList(versionReference, sharedNonVersionReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import de.test.package.dto.group.DummyV1Dto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1 the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1) {");
        expected.add("		return convertToDummy(dummyV1, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1       the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummyV1} is contained, the found {@link Dummy} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummyV1, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto}");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy) {");
        expected.add("		return convertToDummyV1Dto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyV1Dto, (domain, dto) -> getInstance().setDummyV1DtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyV1DtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRef(), dto, mappedObjects);");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRefShared(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRef(), domain, mappedObjects);");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRefShared(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyV1Dto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRefShared(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyV1DtoSingleReferences(Dummy domain, DummyV1Dto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRefShared(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyV1DtoValues(Dummy domain, DummyV1Dto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyV1Dto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");


        getDefaultExpected().forEach(l -> assertTrue(expected.contains(l), "The actual expected has to be an extension of the default one"));
        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @DisplayName("Create transport mapper with a versioned parent entity")
    @Test
    public void testCreateTransportMapperVersionParentSingleRef() {
        entities.add(targetEntity);
        when(entity.getVersions()).thenReturn(Collections.singletonList(version));
        when(targetEntity.getVersions()).thenReturn(Collections.singletonList(targetVersion));

        setMockReturnsReference(sharedVersionReference, versionEntity, versionTargetEntity, null);

        setMockReturnsReference(parentReference, TARGET_REFERENCE_NAME + "Shared", ENTITY_NAME, null, null, Boolean.FALSE, Boolean.TRUE);
        setMockReturnsReference(parentReference, targetEntity, entity, null);
        when(parentReference.isReverse()).thenReturn(Boolean.TRUE);

        when(entity.getReferences()).thenReturn(Collections.singletonList(sharedNonVersionReference));
        when(versionEntity.getReferences()).thenReturn(Collections.singletonList(sharedVersionReference));

        when(targetEntity.getParentRefs()).thenReturn(Collections.singletonList(parentReference));
        when(versionTargetEntity.getParentRefs()).thenReturn(Collections.singletonList(versionParentReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.ma_vin.util.layer.generator.annotations.mapper.BaseTransportMapper;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.Dummy;");
        expected.add("import de.test.package.domain.group.Target;");
        expected.add("import de.test.package.dto.DtoObjectFactory;");
        expected.add("import de.test.package.dto.ITransportable;");
        expected.add("import de.test.package.dto.group.DummyDto;");
        expected.add("import de.test.package.dto.group.DummyV1Dto;");
        expected.add("import de.test.package.dto.group.TargetDto;");
        expected.add("import de.test.package.dto.group.TargetV1Dto;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data transport to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseTransportMapper");
        expected.add("public class GroupingTransportMapper extends AbstractTransportMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingTransportMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDto dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1 the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1) {");
        expected.add("		return convertToDummy(dummyV1, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyV1Dto} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummyV1       the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummyV1} is contained, the found {@link Dummy} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyV1Dto dummyV1, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummyV1, mappedObjects, DomainObjectFactory::createDummy, (dto, domain) -> getInstance().setDummyValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setDummySingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDto}");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy) {");
        expected.add("		return convertToDummyDto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDto} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDto convertToDummyDto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyDto, (domain, dto) -> getInstance().setDummyDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto}");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy) {");
        expected.add("		return convertToDummyV1Dto(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyV1Dto convertToDummyV1Dto(Dummy dummy, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(dummy, mappedObjects, DtoObjectFactory::createDummyV1Dto, (domain, dto) -> getInstance().setDummyV1DtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setDummyV1DtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDto} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDto target) {");
        expected.add("		return convertToTarget(target, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDto} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link Target} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDto target, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(target, mappedObjects, DomainObjectFactory::createTarget, (dto, domain) -> getInstance().setTargetValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setTargetSingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDto} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDto target, Dummy parent) {");
        expected.add("		return convertToTarget(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDto} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link Target} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDto target, Dummy parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Target result = convertToTarget(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setTargetRefShared(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetV1Dto} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param targetV1 the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetV1Dto targetV1) {");
        expected.add("		return convertToTarget(targetV1, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetV1Dto} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param targetV1      the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code targetV1} is contained, the found {@link Target}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetV1Dto targetV1, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(targetV1, mappedObjects, DomainObjectFactory::createTarget, (dto, domain) -> getInstance().setTargetValues(dto, domain)");
        expected.add("				, (dto, domain) -> getInstance().setTargetSingleReferences(dto, domain, mappedObjects)");
        expected.add("				, (dto, domain) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetV1Dto} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param targetV1 the source object which should be converted");
        expected.add("	 * @param parent   the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetV1Dto targetV1, Dummy parent) {");
        expected.add("		return convertToTarget(targetV1, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetV1Dto} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param targetV1      the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code targetV1} is contained, the found {@link Target}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetV1Dto targetV1, Dummy parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		TargetV1 result = convertToTarget(targetV1, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setTargetRefShared(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDto}");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link TargetDto}");
        expected.add("	 */");
        expected.add("	public static TargetDto convertToTargetDto(Target target) {");
        expected.add("		return convertToTargetDto(target, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDto}");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetDto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetDto convertToTargetDto(Target target, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(target, mappedObjects, DtoObjectFactory::createTargetDto, (domain, dto) -> getInstance().setTargetDtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setTargetDtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link TargetDto}");
        expected.add("	 */");
        expected.add("	public static TargetDto convertToTargetDto(Target target, DummyDto parent) {");
        expected.add("		return convertToTargetDto(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetDto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetDto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetDto convertToTargetDto(Target target, DummyDto parent, Map<String, ITransportable> mappedObjects) {");
        expected.add("		TargetDto result = convertToTargetDto(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setTargetRefShared(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link TargetV1Dto}");
        expected.add("	 */");
        expected.add("	public static TargetV1Dto convertToTargetV1Dto(Target target) {");
        expected.add("		return convertToTargetV1Dto(target, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetV1Dto}");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetV1Dto convertToTargetV1Dto(Target target, Map<String, ITransportable> mappedObjects) {");
        expected.add("		return convertToDto(target, mappedObjects, DtoObjectFactory::createTargetV1Dto, (domain, dto) -> getInstance().setTargetV1DtoValues(domain, dto)");
        expected.add("				, (domain, dto) -> getInstance().setTargetV1DtoSingleReferences(domain, dto, mappedObjects)");
        expected.add("				, (domain, dto) -> {");
        expected.add("		});");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetV1Dto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link TargetV1Dto}");
        expected.add("	 */");
        expected.add("	public static TargetV1Dto convertToTargetV1Dto(Target target, DummyV1Dto parent) {");
        expected.add("		return convertToTargetV1Dto(targetV1, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetV1Dto} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetV1Dto}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetV1Dto} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetV1Dto convertToTargetV1Dto(Target target, DummyV1Dto parent, Map<String, ITransportable> mappedObjects) {");
        expected.add("		TargetV1Dto result = convertToTargetV1Dto(targetV1, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setTargetRefShared(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingTransportMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = TransportMapperFactory.createGroupingTransportMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyDtoSingleReferences(Dummy domain, DummyDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetDto(domain.getTargetRefShared(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDtoValues(Dummy domain, DummyDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRefShared(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyV1Dto dto, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTarget(dto.getTargetRefShared(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	protected void setDummyV1DtoSingleReferences(Dummy domain, DummyV1Dto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("		GroupTransportMapper.convertToTargetV1Dto(domain.getTargetRefShared(), dto, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyV1DtoValues(Dummy domain, DummyV1Dto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyV1Dto dto, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetDtoSingleReferences(Target domain, TargetDto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetDtoValues(Target domain, TargetDto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetSingleReferences(TargetDto dto, Target domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dto           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dto} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetSingleReferences(TargetV1Dto dto, Target domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dto} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dto           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dto}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetV1DtoSingleReferences(Target domain, TargetV1Dto dto, Map<String, ITransportable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dto} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dto    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetV1DtoValues(Target domain, TargetV1Dto dto) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetValues(TargetDto dto, Target domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dto} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dto    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetValues(TargetV1Dto dto, Target domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");


        assertTrue(cut.createTransportMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DTO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sTransportMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }
}
