package com.github.ma_vin.util.layer_generator.generator;

import com.github.ma_vin.util.layer_generator.config.elements.Entity;
import com.github.ma_vin.util.layer_generator.config.elements.Models;
import com.github.ma_vin.util.layer_generator.config.elements.fields.NonOwnerFilterField;
import com.github.ma_vin.util.layer_generator.config.elements.references.Reference;
import com.github.ma_vin.util.layer_generator.generator.generator.AbstractCreator;
import com.github.ma_vin.util.layer_generator.generator.generator.AccessMapperCreator;
import com.github.ma_vin.util.layer_generator.logging.Log4jLogImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;

import javax.tools.JavaFileObject;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static org.mockito.Mockito.when;

public class AccessMapperCreatorTest extends AbstractCreatorTest {

    public static final String GROUPING_NAME = "grouping";
    public static final String MAPPER_PACKAGE_NAME = BASE_PACKAGE + ".mapper";
    public static final String DAO_PACKAGE_NAME = BASE_PACKAGE + ".dao";
    public static final String DOMAIN_PACKAGE_NAME = BASE_PACKAGE + ".domain";
    private AccessMapperCreator cut;
    private final List<Entity> entities = new ArrayList<>();

    @Mock
    private Entity parentEntity;
    @Mock
    private Reference toParentReference;
    @Mock
    private Reference fromParentReference;
    @Mock
    private Entity anotherParentEntity;
    @Mock
    private Reference anotherToParentReference;
    @Mock
    private Reference anotherFromParentReference;

    @Mock
    private Entity subEntity;
    @Mock
    private Reference toSubReference;
    @Mock
    private Reference fromSubReference;

    @Override
    @BeforeEach
    public void setUp() {
        super.setUp();
        cut = new AccessMapperCreator(config, new Log4jLogImpl()) {
            @Override
            protected BufferedWriter createBufferedWriter(File classFile) {
                return mockBufferedWriter(classFile.getName());
            }

            @Override
            protected BufferedWriter createBufferedWriter(JavaFileObject javaFileObject) {
                return mockBufferedWriter(javaFileObject.getName());
            }

            @Override
            protected File createFile(File dir, String fileName) {
                File createdFile = mock(File.class);
                when(createdFile.getName()).thenReturn(fileName);
                when(createdFile.getParentFile()).thenReturn(dir);
                return createdFile;
            }
        };

        entities.clear();
        entities.add(entity);
    }

    @Override
    protected void initDefaultMock() {
        super.initDefaultMock();

        when(grouping.getGroupingPackage()).thenReturn(GROUPING_NAME);

        when(parentEntity.getBaseName()).thenReturn("Owner");
        when(parentEntity.getDescription()).thenReturn("Owner description");
        when(parentEntity.getIdentificationPrefix()).thenReturn("OW");
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(parentEntity.getGrouping()).thenReturn(null);
        when(parentEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(parentEntity.hasNoParent()).thenReturn(Boolean.TRUE);
        when(parentEntity.getReferences()).thenReturn(Collections.singletonList(fromParentReference));

        setMockReturnsReference(toParentReference, "dummy", "Owner", null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(toParentReference, null, parentEntity, null);
        setMockReturnsReference(fromParentReference, "dummy", null, null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(fromParentReference, parentEntity, null, null);

        when(anotherParentEntity.getBaseName()).thenReturn("AnotherOwner");
        when(anotherParentEntity.getDescription()).thenReturn("Another owner description");
        when(anotherParentEntity.getIdentificationPrefix()).thenReturn("AOW");
        when(anotherParentEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(anotherParentEntity.getGrouping()).thenReturn(null);
        when(anotherParentEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(anotherParentEntity.hasNoParent()).thenReturn(Boolean.TRUE);
        when(anotherParentEntity.getReferences()).thenReturn(Collections.singletonList(anotherFromParentReference));

        setMockReturnsReference(anotherToParentReference, "anotherDummy", "AnotherOwner", null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, null, anotherParentEntity, null);
        when(anotherToParentReference.isReverse()).thenReturn(Boolean.TRUE);
        setMockReturnsReference(anotherFromParentReference, "anotherDummy", null, null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherFromParentReference, anotherParentEntity, null, null);

        when(subEntity.getBaseName()).thenReturn("Child");
        when(subEntity.getDescription()).thenReturn("child description");
        when(subEntity.getIdentificationPrefix()).thenReturn("CH");
        when(subEntity.getModels()).thenReturn(Models.DOMAIN_DAO_DTO);
        when(subEntity.getGrouping()).thenReturn(grouping);
        when(subEntity.hasParent()).thenReturn(Boolean.FALSE);
        when(subEntity.hasNoParent()).thenReturn(Boolean.TRUE);
        when(subEntity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(fromSubReference));

        setMockReturnsReference(toSubReference, "child", "Child", null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(toSubReference, null, subEntity, null);
        setMockReturnsReference(fromSubReference, "child", null, null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(fromSubReference, subEntity, null, null);
        when(fromSubReference.isReverse()).thenReturn(Boolean.TRUE);
    }

    @DisplayName("create access mapper with common file")
    @Test
    public void testCreateAccessMapper() {
        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);

        verify(processingEnv, never()).getFiler();
    }

    @DisplayName("create access mapper with java file object")
    @Test
    public void testCreateAccessMapperJavaFileObject() throws IOException {
        List<String> expected = getDefaultExpected();
        cut.setGenerateJavaFileObject(true);
        cut.setProcessingEnv(Optional.of(processingEnv));

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.empty()));

        checkSingleFile(String.format("%s.%sAccessMapper", MAPPER_PACKAGE_NAME, AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);

        verify(processingEnv).getFiler();
        verify(filer).createSourceFile(eq(String.format("%s.%sAccessMapper", MAPPER_PACKAGE_NAME, AbstractCreator.getUpperFirst(GROUPING_NAME))));
    }

    private List<String> getDefaultExpected() {
        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        return expected;
    }

    @Test
    public void testCreateAccessMapperField() {
        when(entity.getFields()).thenReturn(Collections.singletonList(field));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("		dao.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("		domain.setAnyField(dao.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRef() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTargetDao(domain.getTargetRef(), dao, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTarget(dao.getTargetRef(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefNotOwner() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(GroupingAccessMapper.convertToTargetDao(domain.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		domain.setTargetRef(GroupingAccessMapper.convertToTarget(dao.getTargetRef(), mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRef() {
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefOwnerAndNotOwner() {
        when(targetReference.getParent()).thenReturn(entity);
        Reference fromTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(fromTargetReference, "TargetRef", "Dummy", null, null, Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(fromTargetReference, targetEntity, entity, null);

        Reference anotherTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(anotherTargetReference, "TargetRef", "Target", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(anotherTargetReference, subEntity, targetEntity, null);

        Reference fromAnotherTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(fromAnotherTargetReference, "TargetRef", "Child", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(fromAnotherTargetReference, targetEntity, subEntity, null);


        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(subEntity.getReferences()).thenReturn(Collections.singletonList(anotherTargetReference));
        when(subEntity.getNonVersionedParentRefs()).thenReturn(Collections.emptyList());
        when(targetEntity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(fromTargetReference, fromAnotherTargetReference));
        entities.add(subEntity);
        entities.add(targetEntity);


        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.ChildDao;");
        expected.add("import de.test.package.dao.grouping.ChildToTargetDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.dao.grouping.TargetDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Child;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import de.test.package.domain.grouping.Target;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link ChildDao} to a(n) {@link Child}");
        expected.add("	 *");
        expected.add("	 * @param child           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Child}");
        expected.add("	 */");
        expected.add("	public static Child convertToChild(ChildDao child, boolean includeChildren) {");
        expected.add("		return convertToChild(child, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link ChildDao} to a(n) {@link Child}");
        expected.add("	 *");
        expected.add("	 * @param child           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code child} is contained, the found {@link Child} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Child} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Child convertToChild(ChildDao child, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(child, mappedObjects, DomainObjectFactory::createChild, (dao, domain) -> getInstance().setChildValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setChildSingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setChildMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Child} to a(n) {@link ChildDao}");
        expected.add("	 *");
        expected.add("	 * @param child           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link ChildDao}");
        expected.add("	 */");
        expected.add("	public static ChildDao convertToChildDao(Child child, boolean includeChildren) {");
        expected.add("		return convertToChildDao(child, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Child} to a(n) {@link ChildDao}");
        expected.add("	 *");
        expected.add("	 * @param child           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code child} is contained, the found {@link ChildDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link ChildDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static ChildDao convertToChildDao(Child child, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(child, mappedObjects, DaoObjectFactory::createChildDao, (domain, dao) -> getInstance().setChildDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setChildDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setChildDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target) {");
        expected.add("		return convertToTarget(target, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target}");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link Target} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(target, mappedObjects, DomainObjectFactory::createTarget, (dao, domain) -> getInstance().setTargetValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setTargetSingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setTargetMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target, Child parent) {");
        expected.add("		return convertToTarget(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link Target} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target, Child parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Target result = convertToTarget(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getTargetRef().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Target}");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target, Dummy parent) {");
        expected.add("		return convertToTarget(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link TargetDao} to a(n) {@link Target} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link Target} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link Target} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Target convertToTarget(TargetDao target, Dummy parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Target result = convertToTarget(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getTargetRef().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao}");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link TargetDao}");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target) {");
        expected.add("		return convertToTargetDao(target, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao}");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetDao}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(target, mappedObjects, DaoObjectFactory::createTargetDao, (domain, dao) -> getInstance().setTargetDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setTargetDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setTargetDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link TargetDao}");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target, ChildDao parent) {");
        expected.add("		return convertToTargetDao(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetDao}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target, ChildDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		TargetDao result = convertToTargetDao(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			ChildToTargetDao connectionTable = DaoObjectFactory.createChildToTargetDao();");
        expected.add("			connectionTable.setTarget(result);");
        expected.add("			connectionTable.setChild(parent);");
        expected.add("			parent.getTargetRef().add(connectionTable);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link TargetDao}");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target, DummyDao parent) {");
        expected.add("		return convertToTargetDao(target, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Target} to a(n) {@link TargetDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param target        the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code target} is contained, the found {@link TargetDao}");
        expected.add("	 *                      will be returned");
        expected.add("	 * @return an equivalent new created {@link TargetDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static TargetDao convertToTargetDao(Target target, DummyDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		TargetDao result = convertToTargetDao(target, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentDummy(parent);");
        expected.add("			parent.getTargetRef().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setChildDaoMultiReferences(Child domain, ChildDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setChildDaoSingleReferences(Child domain, ChildDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setChildDaoValues(Child domain, ChildDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setChildMultiReferences(ChildDao dao, Child domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg.getTarget(), domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setChildSingleReferences(ChildDao dao, Child domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setChildValues(ChildDao dao, Child domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetDaoMultiReferences(Target domain, TargetDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetDaoSingleReferences(Target domain, TargetDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetDaoValues(Target domain, TargetDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetMultiReferences(TargetDao dao, Target domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetSingleReferences(TargetDao dao, Target domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setTargetValues(TargetDao dao, Target domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefNotOwner() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg.getTarget(), domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperParentSingleRef() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(toParentReference));
        when(toParentReference.getParent()).thenReturn(entity);
        when(fromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(fromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);

        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTargetDao(domain.getTargetRef(), dao, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTarget(dao.getTargetRef(), domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");
        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiParentSingleRef() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(toParentReference.getParent()).thenReturn(entity);
        when(fromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(fromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);
        when(anotherToParentReference.getParent()).thenReturn(entity);
        when(anotherFromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(anotherFromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);

        when(toParentReference.isList()).thenReturn(Boolean.FALSE);
        when(anotherToParentReference.isList()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.AnotherOwnerDao;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.AnotherOwner;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setAnotherDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentAnotherOwner(parent);");
        expected.add("			parent.setAnotherDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.setDummy(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");
        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperParentMultiRef() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(toParentReference));
        when(toParentReference.getParent()).thenReturn(entity);
        when(fromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(fromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);

        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetReference.getParent()).thenReturn(entity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Owner parent) {");
        expected.add("		return convertToDummy(dummy, includeChildren, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, includeChildren, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, includeChildren, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefNonOwnerSelfReference() {
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(entity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(targetReference));
        setMockReturnsReference(targetReference, ENTITY_NAME + "s", ENTITY_NAME, null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(targetReference, entity, entity, null);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.dao.grouping.DummyToDummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Dummy parent) {");
        expected.add("		return convertToDummy(dummy, includeChildren, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Dummy parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, includeChildren, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getDummys().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, DummyDao parent) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param parent          the parent of converted result");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, DummyDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, includeChildren, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			DummyToDummyDao connectionTable = DaoObjectFactory.createDummyToDummyDao();");
        expected.add("			connectionTable.setSubDummy(result);");
        expected.add("			connectionTable.setDummy(parent);");
        expected.add("			parent.getDummys().add(connectionTable);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setDummys(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getDummys().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToDummyDao(arg, true, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getDummys().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToDummy(arg.getSubDummy(), true, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiParentMultiRef() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(toParentReference.getParent()).thenReturn(entity);
        when(fromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(fromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);
        when(anotherToParentReference.getParent()).thenReturn(entity);
        when(anotherFromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(anotherFromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.AnotherOwnerDao;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.AnotherOwner;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getAnotherDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentAnotherOwner(parent);");
        expected.add("			parent.getAnotherDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiParentMultiRefOwnerAndNotOwner() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(toParentReference.getParent()).thenReturn(entity);
        when(fromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(fromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);
        when(anotherToParentReference.getParent()).thenReturn(entity);
        when(anotherFromParentReference.getRealTargetEntity()).thenReturn(entity);
        when(anotherFromParentReference.getTargetEntity()).thenReturn(ENTITY_NAME);

        when(anotherToParentReference.isOwner()).thenReturn(Boolean.FALSE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.AnotherOwnerDao;");
        expected.add("import de.test.package.dao.AnotherOwnerToDummyDao;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.AnotherOwner;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, AnotherOwner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getAnotherDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, AnotherOwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			AnotherOwnerToDummyDao connectionTable = DaoObjectFactory.createAnotherOwnerToDummyDao();");
        expected.add("			connectionTable.setDummy(result);");
        expected.add("			connectionTable.setAnotherOwner(parent);");
        expected.add("			parent.getAnotherDummy().add(connectionTable);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Collections.singletonList(toSubReference));
        when(toSubReference.getParent()).thenReturn(targetEntity);
        when(fromSubReference.getRealTargetEntity()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, includeChildren, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, includeChildren, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if all references at sub entities of the single reference should also be mapped. {@code false} if only those");
        expected.add("	 *                        references should be mapped which are not of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTargetDao(domain.getTargetRef(), includeChildren, dao, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if all references at sub entities of the single reference should also be mapped. {@code false} if only those");
        expected.add("	 *                        references should be mapped which are not of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		GroupingAccessMapper.convertToTarget(dao.getTargetRef(), includeChildren, domain, mappedObjects);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }


    @Test
    public void testCreateAccessMapperSingleRefNotOwnerWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Collections.singletonList(toSubReference));
        when(toSubReference.getParent()).thenReturn(targetEntity);
        when(fromSubReference.getRealTargetEntity()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, includeChildren, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, includeChildren, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if all references at sub entities of the single reference should also be mapped. {@code false} if only those");
        expected.add("	 *                        references should be mapped which are not of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(GroupingAccessMapper.convertToTargetDao(domain.getTargetRef(), includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if all references at sub entities of the single reference should also be mapped. {@code false} if only those");
        expected.add("	 *                        references should be mapped which are not of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		domain.setTargetRef(GroupingAccessMapper.convertToTarget(dao.getTargetRef(), includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Collections.singletonList(toSubReference));
        when(toSubReference.getParent()).thenReturn(targetEntity);
        when(fromSubReference.getRealTargetEntity()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, true, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, true, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }


    @Test
    public void testCreateAccessMapperMultiRefNotOwnerWithChildren() {
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isOwner()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));
        when(targetEntity.getReferences()).thenReturn(Collections.singletonList(toSubReference));
        when(toSubReference.getParent()).thenReturn(targetEntity);
        when(fromSubReference.getRealTargetEntity()).thenReturn(targetEntity);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setTargetRef(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, true, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg.getTarget(), true, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperGroupingWithDot() {
        when(grouping.getGroupingPackage()).thenReturn("group.subgroup");

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.group.subgroup.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.group.subgroup.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>group.subgroup<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupSubgroupAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupSubgroupAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupSubgroupAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupSubgroupAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, "group.subgroup", MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", "GroupSubgroup"), expected);
    }

    @Test
    public void testCreateAccessMapperNothingToMap() {
        when(entity.getModels()).thenReturn(Models.DTO);
        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dto");

        when(entity.getModels()).thenReturn(Models.DOMAIN);
        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only domain");

        when(entity.getModels()).thenReturn(Models.DAO);
        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dao");
    }

    @Test
    public void testCreateAccessMapperNoAllToMap() {
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DTO);
        when(subEntity.getModels()).thenReturn(Models.DAO);
        entities.add(parentEntity);
        entities.add(subEntity);

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefParentNotRelevant() {
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DTO);
        when(entity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(toParentReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefParentNotRelevant() {
        when(entity.getNonVersionedParentRefs()).thenReturn(Collections.singletonList(toParentReference));
        when(toParentReference.isList()).thenReturn(Boolean.FALSE);
        when(parentEntity.getModels()).thenReturn(Models.DOMAIN_DTO);

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperMultiRefChildNotRelevant() {
        when(targetEntity.getModels()).thenReturn(Models.DOMAIN_DTO);
        when(targetReference.getParent()).thenReturn(entity);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperSingleRefChildNotRelevant() {
        when(targetEntity.getModels()).thenReturn(Models.DOMAIN_DTO);
        when(targetReference.getParent()).thenReturn(entity);
        when(targetReference.isList()).thenReturn(Boolean.FALSE);
        when(entity.getReferences()).thenReturn(Collections.singletonList(targetReference));

        List<String> expected = getDefaultExpected();

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperAbstract() {
        when(entity.getIsAbstract()).thenReturn(Boolean.TRUE);

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));
        assertEquals(0, writtenFileContents.size(), "No Mapper should be generated for only dto");
    }

    @Test
    public void testCreateAccessMapperWithParent() {
        when(entity.getParent()).thenReturn("AnotherDummy");
        when(entity.getRealParent()).thenReturn(parentEntity);
        when(entity.hasParent()).thenReturn(Boolean.TRUE);
        when(entity.hasNoParent()).thenReturn(Boolean.FALSE);
        when(parentEntity.getIsAbstract()).thenReturn(Boolean.TRUE);
        when(parentEntity.getBaseName()).thenReturn("AnotherDummy");
        when(parentEntity.getReferences()).thenReturn(Collections.singletonList(toSubReference));
        when(parentEntity.getFields()).thenReturn(Collections.singletonList(field));
        when(toSubReference.getParent()).thenReturn(parentEntity);
        when(fromSubReference.getRealTargetEntity()).thenReturn(parentEntity);
        when(fromSubReference.getTargetEntity()).thenReturn("AnotherDummy");

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setChild(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getChild().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToChildDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("		dao.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getChild().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToChild(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("		domain.setAnyField(dao.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperAggregateRef() {
        setMockReturnsReference(targetReference, entity, targetEntity, field);
        setMockReturnsReference(targetReference, "TargetRef", "Target", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        Reference sameTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(sameTargetReference, entity, targetEntity, field);
        setMockReturnsReference(sameTargetReference, "AnotherTargetRef", "Target", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);

        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference, sameTargetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setAggTarget(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("			domain.getAnotherTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getAggTarget().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperAggregateRefFilterIsNotDomain() {
        setMockReturnsReference(targetReference, entity, targetEntity, field);
        setMockReturnsReference(targetReference, "TargetRef", "Target", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        Reference sameTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(sameTargetReference, entity, targetEntity, field);
        setMockReturnsReference(sameTargetReference, "AnotherTargetRef", "Target", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);

        when(field.getModels()).thenReturn(Models.DAO);
        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference, sameTargetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import de.test.package.enums.SomeEnum;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setAggTarget(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, SomeEnum.ENUM_VALUE_A, mappedObjects)");
        expected.add("			);");
        expected.add("			domain.getAnotherTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, SomeEnum.ENUM_VALUE_B, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getAggTarget().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg, domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }


    @Test
    public void testCreateAccessMapperParentAggregateRef() {
        setMockReturnsReference(toParentReference, "someDummy", "Owner", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(toParentReference, entity, parentEntity, field);
        when(toParentReference.isReverse()).thenReturn(Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, "anotherDummy", "Owner", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, entity, parentEntity, field);
        when(anotherToParentReference.isReverse()).thenReturn(Boolean.TRUE);

        setMockReturnsReference(fromParentReference, "someDummy", "Dummy", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(fromParentReference, parentEntity, entity, field);
        setMockReturnsReference(anotherFromParentReference, "anotherDummy", "Dummy", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherFromParentReference, parentEntity, entity, field);

        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(entity.getFields()).thenReturn(Collections.singletonList(field));
        when(parentEntity.getReferences()).thenReturn(Arrays.asList(fromParentReference, anotherFromParentReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("import lombok.extern.log4j.Log4j2;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("@Log4j2");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			switch (dummy.getAnyField()) {");
        expected.add("				case ENUM_VALUE_A:");
        expected.add("					parent.addSomeDummy(result);");
        expected.add("					break;");
        expected.add("				case ENUM_VALUE_B:");
        expected.add("					parent.addAnotherDummy(result);");
        expected.add("					break;");
        expected.add("				default:");
        expected.add("					log.error(\"There is not any mapping rule for dummy of type {}\", dummy.getAnyField());");
        expected.add("			}");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getAggDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("		dao.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("		domain.setAnyField(dao.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperParentAggregateRefFilterIsNotDomain() {
        setMockReturnsReference(toParentReference, "someDummy", "Owner", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(toParentReference, entity, parentEntity, field);
        when(toParentReference.isReverse()).thenReturn(Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, "anotherDummy", "Owner", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, entity, parentEntity, field);
        when(anotherToParentReference.isReverse()).thenReturn(Boolean.TRUE);

        setMockReturnsReference(fromParentReference, "someDummy", "Dummy", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(fromParentReference, parentEntity, entity, field);
        setMockReturnsReference(anotherFromParentReference, "anotherDummy", "Dummy", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.TRUE);
        setMockReturnsReference(anotherFromParentReference, parentEntity, entity, field);

        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(field.getModels()).thenReturn(Models.DAO);
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(entity.getFields()).thenReturn(Collections.singletonList(field));
        when(parentEntity.getReferences()).thenReturn(Arrays.asList(fromParentReference, anotherFromParentReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import de.test.package.enums.SomeEnum;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("import lombok.extern.log4j.Log4j2;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("@Log4j2");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			switch (dummy.getAnyField()) {");
        expected.add("				case ENUM_VALUE_A:");
        expected.add("					parent.addSomeDummy(result);");
        expected.add("					break;");
        expected.add("				case ENUM_VALUE_B:");
        expected.add("					parent.addAnotherDummy(result);");
        expected.add("					break;");
        expected.add("				default:");
        expected.add("					log.error(\"There is not any mapping rule for dummy of type {}\", dummy.getAnyField());");
        expected.add("			}");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy    the source object which should be converted");
        expected.add("	 * @param anyField value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, SomeEnum anyField) {");
        expected.add("		return convertToDummyDao(dummy, anyField, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param anyField      value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, SomeEnum anyField, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao, anyField)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy    the source object which should be converted");
        expected.add("	 * @param parent   the parent of converted result");
        expected.add("	 * @param anyField value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, SomeEnum anyField) {");
        expected.add("		return convertToDummyDao(dummy, parent, anyField, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param anyField      value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, SomeEnum anyField, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, anyField, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			result.setParentOwner(parent);");
        expected.add("			parent.getAggDummy().add(result);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain   source of the given values");
        expected.add("	 * @param dao      object where to set the values");
        expected.add("	 * @param anyField value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao, SomeEnum anyField) {");
        expected.add("		dao.setAnyField(anyField);");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAbstractAccessMapper() {
        File mapperPackageDir = mock(File.class);
        when(mapperPackageDir.getName()).thenReturn("mapperPackageDir");
        when(mapperPackageDir.getParentFile()).thenReturn(null);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated abstract class which provides generic methods to convert a data access to a domain object and the other way around");
        expected.add(" */");
        expected.add("public abstract class AbstractAccessMapper extends AbstractMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiable} to an {@link IIdentifiableDao} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiableDao} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiableDao} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiable, T extends IIdentifiableDao> T convertToDao(S convertFrom, Map<String, IIdentifiableDao> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, s -> s.getClass().getSimpleName() + s.getId().longValue(), (s, t) -> t.setId(s.getId()));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiableDao} to an {@link IIdentifiable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiableDao, T extends IIdentifiable> T convertToDomain(S convertFrom, Map<String, IIdentifiable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, s -> s.getClass().getSimpleName() + s.getId().longValue(), (s, t) -> t.setId(s.getId()));");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAbstractAccessMapper(MAPPER_PACKAGE_NAME, Optional.of(mapperPackageDir), DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME));
        checkSingleFile(String.format("%s.java", AccessMapperCreator.ABSTRACT_ACCESS_MAPPER_CLASS_NAME), expected);
    }

    @Test
    public void testCreateAbstractAccessMapperUseIdGenerator() {
        File mapperPackageDir = mock(File.class);
        when(mapperPackageDir.getName()).thenReturn("mapperPackageDir");
        when(mapperPackageDir.getParentFile()).thenReturn(null);

        when(config.isUseIdGenerator()).thenReturn(Boolean.TRUE);

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated abstract class which provides generic methods to convert a data access to a domain object and the other way around");
        expected.add(" */");
        expected.add("public abstract class AbstractAccessMapper extends AbstractMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiable} to an {@link IIdentifiableDao} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiableDao} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiableDao} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiable, T extends IIdentifiableDao> T convertToDao(S convertFrom, Map<String, IIdentifiableDao> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, S::getIdentification, (s, t) -> t.setIdentification(s.getIdentification()));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts an {@link IIdentifiableDao} to an {@link IIdentifiable} object");
        expected.add("	 *");
        expected.add("	 * @param convertFrom           object which is to converted");
        expected.add("	 * @param mappedObjects         map which contains already mapped objects. If an identification of {@code convertFrom} is contained, the found");
        expected.add("	 *                              {@link IIdentifiable} will be returned");
        expected.add("	 * @param objectCreator         functional interface which is called to create a new instance of {@link IIdentifiable} as result");
        expected.add("	 * @param valueMapper           functional interface which is called to set the values of {@code convertFrom} at result");
        expected.add("	 * @param singleReferenceMapper functional interface which is called to add the single references of {@code convertFrom} at result");
        expected.add("	 * @param multiReferenceMapper  functional interface which is called to add the multi references of {@code convertFrom} at result");
        expected.add("	 * @param <S>                   the type of the source object");
        expected.add("	 * @param <T>                   the type of the target object");
        expected.add("	 * @return an equivalent new created object or the found one from the given map");
        expected.add("	 */");
        expected.add("	protected static <S extends IIdentifiableDao, T extends IIdentifiable> T convertToDomain(S convertFrom, Map<String, IIdentifiable> mappedObjects");
        expected.add("			, ObjectCreator<T> objectCreator, ValueMapper<S, T> valueMapper, ReferenceMapper<S, T> singleReferenceMapper");
        expected.add("			, ReferenceMapper<S, T> multiReferenceMapper) {");
        expected.add("		return convertTo(convertFrom, mappedObjects, objectCreator, valueMapper, singleReferenceMapper, multiReferenceMapper");
        expected.add("				, S::getIdentification, (s, t) -> t.setIdentification(s.getIdentification()));");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAbstractAccessMapper(MAPPER_PACKAGE_NAME, Optional.of(mapperPackageDir), DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME));
        checkSingleFile(String.format("%s.java", AccessMapperCreator.ABSTRACT_ACCESS_MAPPER_CLASS_NAME), expected);
    }

    @Test
    public void testCreateAccessMapperAggregateRefNotOwner() {
        setMockReturnsReference(targetReference, entity, targetEntity, field);
        setMockReturnsReference(targetReference, "TargetRef", "Target", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.FALSE);
        Reference sameTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(sameTargetReference, entity, targetEntity, field);
        setMockReturnsReference(sameTargetReference, "AnotherTargetRef", "Target", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.FALSE);

        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference, sameTargetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setAggTarget(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("			domain.getAnotherTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getAggTarget().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg.getTarget(), domain, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperParentAggregateRefNotOwner() {
        setMockReturnsReference(toParentReference, "someDummy", "Owner", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(toParentReference, entity, parentEntity, field);
        when(toParentReference.isReverse()).thenReturn(Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, "anotherDummy", "Owner", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(anotherToParentReference, entity, parentEntity, field);
        when(anotherToParentReference.isReverse()).thenReturn(Boolean.TRUE);

        setMockReturnsReference(fromParentReference, "someDummy", "Dummy", "anyField", "ENUM_VALUE_A", Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(fromParentReference, parentEntity, entity, field);
        setMockReturnsReference(anotherFromParentReference, "anotherDummy", "Dummy", "anyField", "ENUM_VALUE_B", Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(anotherFromParentReference, parentEntity, entity, field);

        when(field.getType()).thenReturn("SomeEnum");
        when(field.getTypePackage()).thenReturn("de.test.package.enums");
        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(entity.getFields()).thenReturn(Collections.singletonList(field));
        when(parentEntity.getReferences()).thenReturn(Arrays.asList(fromParentReference, anotherFromParentReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.OwnerToDummyDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("import lombok.extern.log4j.Log4j2;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("@Log4j2");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent) {");
        expected.add("		return convertToDummy(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			switch (dummy.getAnyField()) {");
        expected.add("				case ENUM_VALUE_A:");
        expected.add("					parent.addSomeDummy(result);");
        expected.add("					break;");
        expected.add("				case ENUM_VALUE_B:");
        expected.add("					parent.addAnotherDummy(result);");
        expected.add("					break;");
        expected.add("				default:");
        expected.add("					log.error(\"There is not any mapping rule for dummy of type {}\", dummy.getAnyField());");
        expected.add("			}");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy  the source object which should be converted");
        expected.add("	 * @param parent the parent of converted result");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent) {");
        expected.add("		return convertToDummyDao(dummy, parent, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			OwnerToDummyDao connectionTable = DaoObjectFactory.createOwnerToDummyDao();");
        expected.add("			connectionTable.setDummy(result);");
        expected.add("			connectionTable.setOwner(parent);");
        expected.add("			parent.getAggDummy().add(connectionTable);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("		dao.setAnyField(domain.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("		domain.setAnyField(dao.getAnyField());");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperAggregateRefNotOwnerFilter() {
        NonOwnerFilterField nonOwnerFilterField = Mockito.mock(NonOwnerFilterField.class);
        when(nonOwnerFilterField.getFilterFieldPackage()).thenReturn("de.test.package.enums");
        when(nonOwnerFilterField.getFilterFieldType()).thenReturn("SomeEnum");
        when(nonOwnerFilterField.getFilterFieldName()).thenReturn("anyField");
        when(nonOwnerFilterField.getFilterFieldValue()).thenReturn("ENUM_VALUE_A");

        NonOwnerFilterField otherNonOwnerFilterField = Mockito.mock(NonOwnerFilterField.class);
        when(otherNonOwnerFilterField.getFilterFieldPackage()).thenReturn("de.test.package.enums");
        when(otherNonOwnerFilterField.getFilterFieldType()).thenReturn("SomeEnum");
        when(otherNonOwnerFilterField.getFilterFieldName()).thenReturn("anyField");
        when(otherNonOwnerFilterField.getFilterFieldValue()).thenReturn("ENUM_VALUE_B");

        setMockReturnsReference(targetReference, entity, targetEntity, null);
        setMockReturnsReference(targetReference, "TargetRef", "Target", null, null, Boolean.TRUE, Boolean.FALSE);
        when(targetReference.getNonOwnerFilterField()).thenReturn(nonOwnerFilterField);
        when(targetReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);
        Reference sameTargetReference = Mockito.mock(Reference.class);
        setMockReturnsReference(sameTargetReference, entity, targetEntity, null);
        setMockReturnsReference(sameTargetReference, "AnotherTargetRef", "Target", null, null, Boolean.TRUE, Boolean.FALSE);
        when(sameTargetReference.getNonOwnerFilterField()).thenReturn(otherNonOwnerFilterField);
        when(sameTargetReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);

        when(entity.getReferences()).thenReturn(Arrays.asList(targetReference, sameTargetReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import de.test.package.enums.SomeEnum;");
        expected.add("import java.util.ArrayList;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren) {");
        expected.add("		return convertToDummy(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will");
        expected.add("	 *                        be returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren) {");
        expected.add("		return convertToDummyDao(dummy, includeChildren, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy           the source object which should be converted");
        expected.add("	 * @param includeChildren {@code true} if all references should also be mapped. {@code false} if only those references should be mapped which are not");
        expected.add("	 *                        of type {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao}");
        expected.add("	 *                        will be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, includeChildren, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain          source of the given references");
        expected.add("	 * @param dao             object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, boolean includeChildren, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		dao.setAggTarget(new ArrayList<>());");
        expected.add("		if (includeChildren) {");
        expected.add("			domain.getTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, SomeEnum.ENUM_VALUE_A, mappedObjects)");
        expected.add("			);");
        expected.add("			domain.getAnotherTargetRef().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTargetDao(arg, dao, SomeEnum.ENUM_VALUE_B, mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao             source of the given references");
        expected.add("	 * @param domain          object where to add the references");
        expected.add("	 * @param includeChildren {@code true} if references should be mapped. Otherwise {@code false}");
        expected.add("	 * @param mappedObjects   map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, boolean includeChildren, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		if (includeChildren) {");
        expected.add("			dao.getAggTarget().forEach(arg ->");
        expected.add("					GroupingAccessMapper.convertToTarget(arg.getTarget(), domain, arg.getAnyField(), mappedObjects)");
        expected.add("			);");
        expected.add("		}");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }

    @Test
    public void testCreateAccessMapperParentAggregateRefNotOwnerFilter() {
        NonOwnerFilterField nonOwnerFilterField = Mockito.mock(NonOwnerFilterField.class);
        when(nonOwnerFilterField.getFilterFieldPackage()).thenReturn("de.test.package.enums");
        when(nonOwnerFilterField.getFilterFieldType()).thenReturn("SomeEnum");
        when(nonOwnerFilterField.getFilterFieldName()).thenReturn("anyField");
        when(nonOwnerFilterField.getFilterFieldValue()).thenReturn("ENUM_VALUE_A");

        NonOwnerFilterField otherNonOwnerFilterField = Mockito.mock(NonOwnerFilterField.class);
        when(otherNonOwnerFilterField.getFilterFieldPackage()).thenReturn("de.test.package.enums");
        when(otherNonOwnerFilterField.getFilterFieldType()).thenReturn("SomeEnum");
        when(otherNonOwnerFilterField.getFilterFieldName()).thenReturn("anyField");
        when(otherNonOwnerFilterField.getFilterFieldValue()).thenReturn("ENUM_VALUE_B");


        setMockReturnsReference(toParentReference, "someDummy", "Owner", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(toParentReference, entity, parentEntity, null);
        when(toParentReference.isReverse()).thenReturn(Boolean.TRUE);
        setMockReturnsReference(anotherToParentReference, "anotherDummy", "Owner", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(anotherToParentReference, entity, parentEntity, null);
        when(anotherToParentReference.isReverse()).thenReturn(Boolean.TRUE);
        when(toParentReference.getNonOwnerFilterField()).thenReturn(nonOwnerFilterField);
        when(anotherToParentReference.getNonOwnerFilterField()).thenReturn(otherNonOwnerFilterField);
        when(toParentReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);
        when(anotherToParentReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);

        setMockReturnsReference(fromParentReference, "someDummy", "Dummy", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(fromParentReference, parentEntity, entity, null);
        setMockReturnsReference(anotherFromParentReference, "anotherDummy", "Dummy", null, null, Boolean.TRUE, Boolean.FALSE);
        setMockReturnsReference(anotherFromParentReference, parentEntity, entity, null);
        when(fromParentReference.getNonOwnerFilterField()).thenReturn(nonOwnerFilterField);
        when(anotherFromParentReference.getNonOwnerFilterField()).thenReturn(otherNonOwnerFilterField);
        when(fromParentReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);
        when(anotherFromParentReference.isConnectionFiltering()).thenReturn(Boolean.TRUE);


        when(entity.getNonVersionedParentRefs()).thenReturn(Arrays.asList(toParentReference, anotherToParentReference));
        when(parentEntity.getReferences()).thenReturn(Arrays.asList(fromParentReference, anotherFromParentReference));

        List<String> expected = new ArrayList<>();
        expected.add("package de.test.package.mapper;");
        expected.add("");
        expected.add("import com.github.ma_vin.util.layer_generator.annotations.mapper.BaseAccessMapper;");
        expected.add("import de.test.package.dao.DaoObjectFactory;");
        expected.add("import de.test.package.dao.IIdentifiableDao;");
        expected.add("import de.test.package.dao.OwnerDao;");
        expected.add("import de.test.package.dao.OwnerToDummyDao;");
        expected.add("import de.test.package.dao.grouping.DummyDao;");
        expected.add("import de.test.package.domain.DomainObjectFactory;");
        expected.add("import de.test.package.domain.IIdentifiable;");
        expected.add("import de.test.package.domain.Owner;");
        expected.add("import de.test.package.domain.grouping.Dummy;");
        expected.add("import de.test.package.enums.SomeEnum;");
        expected.add("import java.util.HashMap;");
        expected.add("import java.util.Map;");
        expected.add("import lombok.extern.log4j.Log4j2;");
        expected.add("");
        expected.add("/**");
        expected.add(" * Generated class which provides methods to convert a data access to a domain object of sub package <i>grouping<i> and the other way around");
        expected.add(" */");
        expected.add("@BaseAccessMapper");
        expected.add("@Log4j2");
        expected.add("public class GroupingAccessMapper extends AbstractAccessMapper {");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * singleton");
        expected.add("	 */");
        expected.add("	private static GroupingAccessMapper instance;");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy) {");
        expected.add("		return convertToDummy(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		return convertToDomain(dummy, mappedObjects, DomainObjectFactory::createDummy, (dao, domain) -> getInstance().setDummyValues(dao, domain)");
        expected.add("				, (dao, domain) -> getInstance().setDummySingleReferences(dao, domain, mappedObjects)");
        expected.add("				, (dao, domain) -> getInstance().setDummyMultiReferences(dao, domain, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy    the source object which should be converted");
        expected.add("	 * @param parent   the parent of converted result");
        expected.add("	 * @param anyField value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link Dummy}");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, SomeEnum anyField) {");
        expected.add("		return convertToDummy(dummy, parent, anyField, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link DummyDao} to a(n) {@link Dummy} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param anyField      value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link Dummy} will be");
        expected.add("	 *                      returned");
        expected.add("	 * @return an equivalent new created {@link Dummy} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static Dummy convertToDummy(DummyDao dummy, Owner parent, SomeEnum anyField, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("		Dummy result = convertToDummy(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			switch (anyField) {");
        expected.add("				case ENUM_VALUE_A:");
        expected.add("					parent.addSomeDummy(result);");
        expected.add("					break;");
        expected.add("				case ENUM_VALUE_B:");
        expected.add("					parent.addAnotherDummy(result);");
        expected.add("					break;");
        expected.add("				default:");
        expected.add("					log.error(\"There is not any mapping rule for dummy of type {}\", anyField);");
        expected.add("			}");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy the source object which should be converted");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy) {");
        expected.add("		return convertToDummyDao(dummy, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao}");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		return convertToDao(dummy, mappedObjects, DaoObjectFactory::createDummyDao, (domain, dao) -> getInstance().setDummyDaoValues(domain, dao)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoSingleReferences(domain, dao, mappedObjects)");
        expected.add("				, (domain, dao) -> getInstance().setDummyDaoMultiReferences(domain, dao, mappedObjects));");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy    the source object which should be converted");
        expected.add("	 * @param parent   the parent of converted result");
        expected.add("	 * @param anyField value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @return an equivalent new created {@link DummyDao}");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, SomeEnum anyField) {");
        expected.add("		return convertToDummyDao(dummy, parent, anyField, new HashMap<>());");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Converts a(n) {@link Dummy} to a(n) {@link DummyDao} and sets the result to the corresponding reference property at the parent");
        expected.add("	 *");
        expected.add("	 * @param dummy         the source object which should be converted");
        expected.add("	 * @param parent        the parent of converted result");
        expected.add("	 * @param anyField      value to map between domain multiple {@link java.util.Collection}s and dao aggregated {@link java.util.Collection}");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. If an identification of {@code dummy} is contained, the found {@link DummyDao} will");
        expected.add("	 *                      be returned");
        expected.add("	 * @return an equivalent new created {@link DummyDao} or the found one from the given map");
        expected.add("	 */");
        expected.add("	public static DummyDao convertToDummyDao(Dummy dummy, OwnerDao parent, SomeEnum anyField, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("		DummyDao result = convertToDummyDao(dummy, mappedObjects);");
        expected.add("		if (result != null) {");
        expected.add("			OwnerToDummyDao connectionTable = DaoObjectFactory.createOwnerToDummyDao();");
        expected.add("			connectionTable.setDummy(result);");
        expected.add("			connectionTable.setOwner(parent);");
        expected.add("			connectionTable.setAnyField(anyField);");
        expected.add("			parent.getAggDummy().add(connectionTable);");
        expected.add("		}");
        expected.add("		return result;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * @return the singleton");
        expected.add("	 */");
        expected.add("	public static GroupingAccessMapper getInstance() {");
        expected.add("		if (instance == null) {");
        expected.add("			instance = AccessMapperFactory.createGroupingAccessMapper();");
        expected.add("		}");
        expected.add("		return instance;");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoMultiReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code dao} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param domain        source of the given references");
        expected.add("	 * @param dao           object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code domain} to {@code dao}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoSingleReferences(Dummy domain, DummyDao dao, Map<String, IIdentifiableDao> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code domain} to {@code dao} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param domain source of the given values");
        expected.add("	 * @param dao    object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyDaoValues(Dummy domain, DummyDao dao) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyMultiReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Adds the references at {@code domain} which are not of type {@link java.util.Collection}");
        expected.add("	 *");
        expected.add("	 * @param dao           source of the given references");
        expected.add("	 * @param domain        object where to add the references");
        expected.add("	 * @param mappedObjects map which contains already mapped objects. It will be used while mapping sub entities of {@code dao} to {@code domain}");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummySingleReferences(DummyDao dao, Dummy domain, Map<String, IIdentifiable> mappedObjects) {");
        expected.add("	}");
        expected.add("");
        expected.add("	/**");
        expected.add("	 * Takes over values from {@code dao} to {@code domain} which are not of reference type");
        expected.add("	 *");
        expected.add("	 * @param dao    source of the given values");
        expected.add("	 * @param domain object where to set the values");
        expected.add("	 */");
        expected.add("	@SuppressWarnings(\"java:S1186\")");
        expected.add("	protected void setDummyValues(DummyDao dao, Dummy domain) {");
        expected.add("	}");
        expected.add("");
        expected.add("}");

        assertTrue(cut.createAccessMapper(entities, GROUPING_NAME, MAPPER_PACKAGE_NAME, DAO_PACKAGE_NAME, DOMAIN_PACKAGE_NAME, Optional.of(basePackageDir)));

        checkSingleFile(String.format("%sAccessMapper.java", AbstractCreator.getUpperFirst(GROUPING_NAME)), expected);
    }
}
